var x = 42  # integer

func f(x; offset=0) { return (x) }

func z(x; delimiter=r'\', other="hi $x") { return (x) }

var y = f(42)  # function call

var z = f(42; offset=5)  # semi-colon doesn't end the expression

# comment afterward
var r2 = r'C:\Program # Files\' # r'' prefix is allowed

var a = [0, 1, 2]

# nested
var b = [a[2], a[1], a[0]]

var c = (f(2), f(1), f(0), {})

pp (1 + (a[1] + 3)); echo next

pp (1 + 
    (a[1] + 3)); echo next
# f(x)

pp ('hi' ++ "hi $x" ++ r'c:\' ++ b'\n')

echo {a,b}@example.com

if (42 > a[0]) {
  echo 'yes'
}

for i, item in (a) {
  echo "$i $item"
}

pp [a]

# todo: this isn't an expression!
echo *.[ch]

# Backslash escapes

echo \( hi \) \[ hi \]


: '''
" TODO:
"
" More structure
"
" - backslash escapes within strings:
"    - \" \$ in double quotes
"    - \u{123456} in J8-style strings
"
" - Is there way to understand recursion like ${a:-'foo'}?  Or just leave that
"   out
" - There is also recursion of $(hostname) and such.
"
" - Here docs?  They are hard, could leave them out of YSH
'''

#
# Copied from notes.md
#


# Command mode -> Expression

    var y = f(42)
    var y = f('str' ++ "hi $x")

    = f(42)
    call f(42)
    pp (f(42))
    pp [f(42)]

    echo ls --flag=$[x + 1]; echo next   # newline not allowed in $[]
    # escape dollar
    echo ls --flag=\$[x + 1]  

    echo @[glob('*.py')]; echo next  # newline not allowed in @[]
    # escape
    echo \@[glob]

# Command mode -> Double quoted

    echo "hi $x"
    echo $"explicit $x"

# Expression mode -> Command

    = :| foo.txt *.py "$x" |   # note: no redirects here though
    = :| $x $(echo hi) @(echo hi) $[42+1] @[a] |   # note: no redirects here though
    = :| \' \" \$ \@ \( \) \[ \] |   # backslash quoting

    = $(echo command sub)
    = @(echo spliced command sub)
    = ^(echo unevaluated)

# Expression mode -> Double Quoted

    = "hi $x"
    = $"explicit $x"
    = ^"unevaluated $x"
    = f(^"unevaluated $x")

# Double-Quoted mode ->

    echo "greeting = $(echo hi)"  # Command
    echo "sum = $[x + 99]"        # Expression

# No change

    echo $(echo hi)
    echo @(echo hi)

    # TODO: should implement these two in YSH!
    #= $[42 + a[i]]
    #= @[a]
    = ^[42 + a[i]]

# Multi-line versions

    func g(...args) { return (args[0]) }

    var y = g(42,
              43,
              f(5))

    # hard cases with ;
    var z = f(1); echo hi
    var z = g(1, 2,
              3); echo hi

    setvar a[0 + 0] = 42

    = g(42,
        43,
        f(5))

    call g(42,
           43,
           f(5))

    var d = len({
      k1: 'value',
      k2: g(5,
            6, 7),
      bracket: [
        1, 2, 3
      ],
    }) + 42
